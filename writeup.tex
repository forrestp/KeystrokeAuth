%
%   latex writeup for KeystrokeAuth
%   6.858 Final Project
%   December 2013
%   forrestp, ameeshg, kseibert, cbieden
%
%

\documentclass{article}

\usepackage{geometry}
\geometry{letterpaper}

\usepackage{doc}

\usepackage{graphicx}

\usepackage{epstopdf}

\usepackage{enumitem}
\setdescription{leftmargin=\parindent,labelindent=1cm}

\title{KeystrokeAuth}
\author{
  Forrest Pieper\\
  Carlo Biedenharn\\
  Kenneth Seibert\\
  Ameesh Goyal
}
\date{December 13th, 2013}

\begin{document}

\maketitle

\abstract{
}

\section{Introduction}
\label{introduction}
KeystrokeAuth is an example website implementation that uses keystroke timing to provide stronger user authentication.
Measuring keystroke timing is a method for passive biometric authentication. 
Traditional biometric authentication such as fingerprint or retinal scanners require external hardware and is not suited for web service authentication where users may login from a variety of machines. 
Keystroke timing can be gathered using javascript embedded in the login and registration pages.
Thus this method requires no additional hardware.
The user must enter her password several times during registration instead of just once or twice, but other than that this method is completely unobstrusive.
Authenticating passwords with keystroke timing makes it more difficult for an attacker who possesses a user's plaintext password to compromise the account.
Additionally, it discourages account sharing which may be useful for highly secure systems and premium acconts.
In this paper we describe past work on the topic, introduce our example implementation called KeystrokeAuth, analyze the added security of our system, and examine a small set of test data.

\section{Background and Related Work}

Many different studies have been done in the past about fingerprinting users based on keystroke cadence, a few of which are referenced below. However, many of these studies focus on running a keylogger in the background of a user session and collecting a large amount of keystrokes before making a decision. The model that these keystrokes are compared to can also be quite large. In contrast, KeystrokeAuth can only compare the timing data from a short password entry to the timing data of a small bank of previously entered passwords. This makes detecting adversaries much more difficult.

In our system, we avoided the legwork of comparing multiple algorithms for what may be the best fit for us. Instead, we chose a few of the top performing algorithms described in {[}1{]} to test in a password context. In particular, the Mahalanobis distance described below performed very well in {[}1{]} and is described in more detail in {[}2{]}. 

\section{KeystrokeAuth Implementation}
KeystrokeAuth uses Javascript to capture the timestamps on each keydown and keyup event while typing the password.
During registration, the user enters her password 10 times.
The data is sent to the server and KeystrokeAuth computes a model specific to that user and password.
When logging in, the user enters the password once and KeystrokeAuth compares the new timing data to the registered model.
If the timing data differs too much, the user will not be logged in.

\subsection{Gathering Timing Data}
Timing data is gathered with Javascript event handlers on key presses in the registration and login pages. Any key that is not a valid password character, e.g. backspace or the arrow keys, causes the entire password field to reset. This ensures we only get timing data for a continous entry of password characters.

Addtionally, some tables and logs indicating which of the models passed and failed are printed out to the page after submission. This is useful for debugging purposes, but should be turned off for an real-world implementation.


\subsection{Generating User Timing Model}
In order to have success with verifying users using keystroke dynamics, we first have to collect a set of training data. The keystroke dynamics that we are interested in include down time, down-down time, flight time, and dwell time which are defined below. 
\begin{description}
	\item[Down time:] The time that each key is pressed down at, where the first key pressed down equates to a time of zero
	\item[Down-Down time:] The time in-between two consecutive key down events
	\item[Flight time:] The time in-between a key up and the following key down event. This value can be negative as a key may not be released before the next is pressed down. 
	\item[Dwell time:] The time that a given key is held down
\end{description}
We are able to calculate all of these values from the initial 10 password entries that are passed in during registration. The calculated data is then encrypted with AES CFB encryption using a salted and hashed (PBKDF2) user password as the key. The salt in this case differs from the salt and hash of the user password that is stored on the server. Thus, for each user, the server stores the username, two different salts, the hashed and salted password, and the encrypted timing data.

These metrics will be used when a login attempt is received to determine whether or not to authenticate a given user.

\subsection{Login Timing Authentication}
In order to determine whether or not the user attempting to log in should be authenticated, we collect the down time, the down-down time, the flight time, and the dwell time to compare against the training data. We make use of the mahalanobis distance to compute the similarity between two vectors.  \\
\begin{displaymath}
D_m(\vec{x}) = \sqrt{(\vec{x}-\vec{y})^T S^{-1} (\vec{x}-\vec{y})}
\end{displaymath} \\
We make use of the mahalanobis distance in both of authentication functions. The first function we use takes the mean of the training data vectors and computes the distance between the login attempt and the computed mean vector. If the distance from the mean vector is below a certain threshold, then the login attempt is accepted. The 2nd function that we employ is we take the login attempt and find its distance from each of the training vectors. If the $k$ closes distances all fall below a threshold, then the login attempt is accepted. \\ \\
The threshold is computed using the training data. We find the mahalanobis distance between each vector in the training data. We then compute the average distance. The threshold is set to be one deviation away from the mean in the direction of smaller distances. In other words we only accept login attempts where the distance of the attempt is at least one deviation than our computed mean distance. 
\section{Security Analysis}
TODO: forrest

proof that security is not worse

strategy: make it no less convinient/difficult for users, and at least slightly more secure

\section{Data Collection and Analysis}
TODO: carlo

\subsection{Data Overview}
% how you gathered data
% graphs demonstrating biometric uniqueness

\subsection{Feature Comparison} %dwell vs flight vs down-down etc.
%table of which features they pass both detectors 


\subsection{Error Rates}    %false positive (someone else logs in) and false negative (I can't log in)

Goal: Find ideal thresholds and weights for each feature that give 1\% false negative rate
ideal would be  .001\% false positive, but anything less than 100\% is an improvement over state of the art
Compromise: increase false positive rate to accomodate 1\% false negative

\section{Conclusion}
TODO: forrest / carlo / kenny / ameesh


\begin{thebibliography}{99}
  \bibitem{Killourhy09}
    %comparison of various keystroke timing schemes
   Killourhy, Kevin S., and Roy A. Maxion. 
   ``Comparing anomaly-detection algorithms for keystroke dynamics.''
   \textit{Dependable Systems \& Networks, 2009. DSN'09. IEEE/IFIP International Conference on.}
   IEEE, 2009. 
 
 \bibitem{Cho00}
    %Nearest-neighbor mahalanobis
   Cho, Sungzoon, et al.
   ``Web-based keystroke dynamics identity verification using neural network.'' 
   \textit{Journal of organizational computing and electronic commerce}
   10.4 (2000): 295-307.
  
\end{thebibliography}

\end {document}
